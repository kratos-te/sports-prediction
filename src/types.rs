use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Sports supported by the trading bot
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum Sport {
    NFL,
    NBA,
    PremierLeague,
    MLB,
}

impl Sport {
    pub fn as_str(&self) -> &str {
        match self {
            Sport::NFL => "NFL",
            Sport::NBA => "NBA",
            Sport::PremierLeague => "Premier League",
            Sport::MLB => "MLB",
        }
    }
}

/// Market types
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MarketType {
    Moneyline,
    Spread,
    Total,
    Prop,
}

/// Market status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MarketStatus {
    Active,
    Closed,
    Resolved,
}

/// Trading position
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum Position {
    Yes,
    No,
}

impl Position {
    pub fn as_str(&self) -> &str {
        match self {
            Position::Yes => "yes",
            Position::No => "no",
        }
    }
}

/// Market information from Polymarket
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Market {
    pub market_id: String,
    pub sport: Sport,
    pub event_name: String,
    pub event_time: DateTime<Utc>,
    pub market_type: MarketType,
    pub description: Option<String>,
    pub resolution_source: Option<String>,
    pub min_liquidity: Decimal,
    pub current_liquidity: Decimal,
    pub yes_price: Decimal,
    pub no_price: Decimal,
    pub status: MarketStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

impl Market {
    /// Calculate implied probability from price
    pub fn implied_probability(&self, position: Position) -> Decimal {
        match position {
            Position::Yes => self.yes_price,
            Position::No => self.no_price,
        }
    }

    /// Check if market has sufficient liquidity
    pub fn has_sufficient_liquidity(&self, min_liquidity: Decimal) -> bool {
        self.current_liquidity >= min_liquidity
    }
}

/// Trading strategy types
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum Strategy {
    ClvArbitrage,
    PoissonExpectedValue,
    NewsScalping,
    MarketMicrostructure,
    SentimentGap,
}

impl Strategy {
    pub fn as_str(&self) -> &str {
        match self {
            Strategy::ClvArbitrage => "clv_arb",
            Strategy::PoissonExpectedValue => "poisson_ev",
            Strategy::NewsScalping => "news_scalp",
            Strategy::MarketMicrostructure => "market_micro",
            Strategy::SentimentGap => "sentiment_gap",
        }
    }
}

/// Trading signal generated by strategies
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signal {
    pub signal_id: Uuid,
    pub market_id: String,
    pub strategy: Strategy,
    pub signal_type: SignalType,
    pub confidence: Decimal,
    pub edge_size: Decimal,
    pub recommended_size: Decimal,
    pub current_price: Decimal,
    pub fair_value: Decimal,
    pub generated_at: DateTime<Utc>,
    pub metadata: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SignalType {
    BuyYes,
    BuyNo,
}

impl SignalType {
    pub fn to_position(&self) -> Position {
        match self {
            SignalType::BuyYes => Position::Yes,
            SignalType::BuyNo => Position::No,
        }
    }
}

/// Trade execution record
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Trade {
    pub trade_id: Uuid,
    pub market_id: String,
    pub strategy: Strategy,
    pub position: Position,
    pub quantity: Decimal,
    pub entry_price: Decimal,
    pub exit_price: Option<Decimal>,
    pub entry_time: DateTime<Utc>,
    pub exit_time: Option<DateTime<Utc>>,
    pub gas_cost: Option<Decimal>,
    pub slippage: Option<Decimal>,
    pub pnl: Option<Decimal>,
    pub pnl_percent: Option<Decimal>,
    pub status: TradeStatus,
    pub tx_hash_entry: Option<String>,
    pub tx_hash_exit: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum TradeStatus {
    Open,
    Closed,
    StoppedOut,
}

impl Trade {
    /// Calculate current unrealized PnL
    pub fn unrealized_pnl(&self, current_price: Decimal) -> Decimal {
        if self.status != TradeStatus::Open {
            return Decimal::ZERO;
        }
        (current_price - self.entry_price) * self.quantity
    }

    /// Calculate position size in USD
    pub fn position_size_usd(&self) -> Decimal {
        self.entry_price * self.quantity
    }
}

/// Bookmaker odds for reference
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BookmakerOdds {
    pub bookmaker: Bookmaker,
    pub market_id: String,
    pub yes_odds: Decimal,
    pub no_odds: Decimal,
    pub yes_implied_prob: Decimal,
    pub no_implied_prob: Decimal,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum Bookmaker {
    Pinnacle,
    Betfair,
    DraftKings,
    FanDuel,
}

impl Bookmaker {
    pub fn as_str(&self) -> &str {
        match self {
            Bookmaker::Pinnacle => "pinnacle",
            Bookmaker::Betfair => "betfair",
            Bookmaker::DraftKings => "draftkings",
            Bookmaker::FanDuel => "fanduel",
        }
    }
}

/// Risk parameters
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskLimits {
    pub max_position_size_pct: Decimal,
    pub daily_drawdown_limit_pct: Decimal,
    pub max_correlation: Decimal,
    pub min_market_liquidity: Decimal,
    pub max_daily_trades: i32,
    pub cooldown_after_losses: i32,
    pub cooldown_period_minutes: i32,
    pub kelly_fraction: Decimal,
    pub min_edge_size: Decimal,
}

impl Default for RiskLimits {
    fn default() -> Self {
        use rust_decimal_macros::dec;
        Self {
            max_position_size_pct: dec!(2.0),
            daily_drawdown_limit_pct: dec!(8.0),
            max_correlation: dec!(0.6),
            min_market_liquidity: dec!(5000.0),
            max_daily_trades: 20,
            cooldown_after_losses: 3,
            cooldown_period_minutes: 60,
            kelly_fraction: dec!(0.5),
            min_edge_size: dec!(0.03),
        }
    }
}

/// Portfolio state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PortfolioState {
    pub total_capital: Decimal,
    pub available_capital: Decimal,
    pub invested_capital: Decimal,
    pub unrealized_pnl: Decimal,
    pub realized_pnl_today: Decimal,
    pub daily_drawdown: Decimal,
    pub max_drawdown: Decimal,
    pub open_positions: i32,
    pub trades_today: i32,
    pub timestamp: DateTime<Utc>,
}

impl PortfolioState {
    /// Calculate position size using Kelly Criterion
    pub fn calculate_position_size(
        &self,
        edge: Decimal,
        win_prob: Decimal,
        kelly_fraction: Decimal,
        max_position_pct: Decimal,
    ) -> Decimal {
        use rust_decimal_macros::dec;
        
        // Kelly formula: f = (bp - q) / b
        // where b = odds - 1, p = win probability, q = 1 - p
        let odds = dec!(1.0) / win_prob;
        let b = odds - dec!(1.0);
        let q = dec!(1.0) - win_prob;
        
        let kelly = if b > dec!(0.0) {
            ((b * win_prob) - q) / b
        } else {
            dec!(0.0)
        };
        
        // Apply Kelly fraction and max position limit
        let fractional_kelly = kelly * kelly_fraction;
        let max_position = self.total_capital * (max_position_pct / dec!(100.0));
        let kelly_position = self.total_capital * fractional_kelly;
        
        kelly_position.min(max_position).max(dec!(0.0))
    }
}

/// Performance metrics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceMetrics {
    pub sharpe_ratio: Decimal,
    pub sortino_ratio: Decimal,
    pub max_drawdown: Decimal,
    pub win_rate: Decimal,
    pub profit_factor: Decimal,
    pub total_trades: i32,
    pub total_pnl: Decimal,
}
